### 数组

初始化一个数组，不知道它内部元素的情况下，推荐使用构造函数创建数组的方法

```
//不传任何参数，得到一个空数组
const arr = new Array()
//指定长度数组
const arr = new Array(7)
//指定长度，指定元素的数组
const arr = new Array(7).fill(7)
```

从性能上看，for循环遍历起来是最快的

### 栈和队列

栈和队列的实现一般都依赖于数组

#### 栈（Stack）

后进先出(LIFO，last in first out)的数据结构

只用pop和push完成增删的数组

- 只允许从尾部添加元素
- 只允许从尾部取出元素

> 形象记忆：拿东西，后放进去的在表层，可以最先拿出来

#### 队列（Quene）

先进先出（FIFO,First in first out）的数据结构

只用push和shift完成增删的数组

- 只允许从尾部添加元素
- 只允许从头部移除元素

> 形象记忆：排队吃饭，先进先出


### 链表

和数组相似，又是有序的列表，都是线性结构（有且只有一个前驱，有且只有一个后继）

#### 不同点

数据单位的名称叫做“结点”，结点和结点的分布，在内存中可以是离散的

在链表中，每一个结点的结构都包括了两部分内容：
1. 数据域(存储的是当前结点所存储的数据值)
2. 指针域(代表下一个结点-后继结点的引用)

```
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
}

function ListNode(val) {
    this.val = val;
    this.next = null;
}
```

链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。

#### 链表的删除

**重点:定位目标结点的前驱结点**

```
const target = node1.next
node1.next = target.next
```

### 链表和数组的辨析

链表的插入/删除效率较高，而访问效率较低；
数组的访问效率较高，而插入效率较低。

> 我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。

> 不管结点个数n有多大，只要明确了要插入/删除的目标位置，要做的仅仅是改变目标结点及其前驱/后继结点的指针指向。链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。

> 随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

> 链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它

> 但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))

**JS数组未必是真正的数组**

数组定义了不同类型的元素，对应的是一段非连续的内存，JS数组在此时不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现。
```
const arr = ['haha',1,{a:1}]
```
> 真正的数组：“存储在连续的内存空间里”这样的必要条件

链表明显的优点：
添加和删除元素都不需要挪动多余的元素。



### 树

- “度”：一个结点开叉出去多少个子树，被记为结点的“度”
- 叶子结点：度为0的结点
- 叶子结点高度为1，每向上一层高度加一，逐层向上累加至目标结点，所得的的值就是目标结点的高度，树中结点的最大高度称为“树的高度”
- 根结点所在的为第一层，子结点所在的为第二层

#### 二叉树

二叉树是指满足以下要求的树：

- 它可以没有根结点，作为一棵空树存在
- 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

在 JS 中，二叉树使用对象来定义。它的结构分为三块：

数据域
左侧子结点（左子树根结点）的引用
右侧子结点（右子树根结点）的引用


##### 遍历方式

按遍历顺序分为：
- 先序遍历
- 中序遍历
- 后序遍历
- 层次遍历

按实现方式分为：
- 递归遍历（先、中、后序遍历）
- 迭代遍历（层次遍历）


先序遍历：根结点 -> 左子树 -> 右子树
中序遍历：左子树 -> 根结点 -> 右子树
后序遍历：左子树 -> 右子树 -> 根结点
> 对于根结点遍历的位置来定的

