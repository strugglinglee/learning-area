(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{310:function(a,e,t){"use strict";t.r(e);var s=t(13),r=Object(s.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"镜像-image"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#镜像-image"}},[a._v("#")]),a._v(" 镜像（Image）")]),a._v(" "),e("h4",{attrs:{id:"docker-image-ls"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-image-ls"}},[a._v("#")]),a._v(" docker image ls")]),a._v(" "),e("p",[a._v("列出已经下载下来的镜像")]),a._v(" "),e("blockquote",[e("p",[a._v("docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话需要执行此命令"),e("code",[a._v("docker image ls -a")])])]),a._v(" "),e("h4",{attrs:{id:"docker-system-df"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-system-df"}},[a._v("#")]),a._v(" docker system df")]),a._v(" "),e("p",[a._v("查看镜像、容器、数据卷所占用的空间")]),a._v(" "),e("h4",{attrs:{id:"docker-image-prune"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-image-prune"}},[a._v("#")]),a._v(" docker image prune")]),a._v(" "),e("p",[a._v("删除虚悬镜像")]),a._v(" "),e("blockquote",[e("p",[a._v("虚悬镜像(dangling image) : 由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 "),e("code",[a._v("<none>")]),a._v(" 的镜像。这类无标签镜像也被称为虚悬镜像。")])]),a._v(" "),e("h4",{attrs:{id:"强大的过滤器参数-filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强大的过滤器参数-filter"}},[a._v("#")]),a._v(" 强大的过滤器参数 --filter")]),a._v(" "),e("p",[a._v("docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker image ls -f since=mongo:3.2\n")])])]),e("blockquote",[e("p",[a._v("想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。")])]),a._v(" "),e("p",[a._v("如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker image ls -f label=com.example.version=0.1\n")])])]),e("h3",{attrs:{id:"容器-container"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器-container"}},[a._v("#")]),a._v(" 容器（Container）")]),a._v(" "),e("h4",{attrs:{id:"新建并启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新建并启动"}},[a._v("#")]),a._v(" 新建并启动")]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[a._v("docker run\n")])])]),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[a._v("docker run "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("t "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("i ubuntu"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("18.04")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("bin"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("bash\n")])])]),e("p",[a._v("-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。")]),a._v(" "),e("h4",{attrs:{id:"启动已终止容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动已终止容器"}},[a._v("#")]),a._v(" 启动已终止容器")]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[a._v("docker container start\n")])])]),e("p",[e("strong",[a._v("在伪终端中利用 "),e("code",[a._v("ps")]),a._v(" 或 "),e("code",[a._v("top")]),a._v(" 来查看进程信息")])]),a._v(" "),e("h4",{attrs:{id:"守护态运行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#守护态运行"}},[a._v("#")]),a._v(" 守护态运行")]),a._v(" "),e("p",[a._v("需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 "),e("code",[a._v("-d")]),a._v(" 参数来实现")]),a._v(" "),e("p",[a._v("可以通过以下命令查看")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("docker logs\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);