(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{494:function(e,t,a){"use strict";a.r(t);var n=a(65),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"理解代码分割"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解代码分割"}},[e._v("#")]),e._v(" 理解代码分割")]),e._v(" "),a("p",[e._v("代码分割是 webpack 中最引人注目的特性之一。此特性能够把代码分割到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分割可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。")]),e._v(" "),a("p",[e._v("常用的代码分割方法有三种：")]),e._v(" "),a("ul",[a("li",[e._v("入口起点：使用 entry 配置手动地分离代码。")]),e._v(" "),a("li",[e._v("防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。")]),e._v(" "),a("li",[e._v("动态导入：通过模块的内联函数调用来分离代码。")])]),e._v(" "),a("h3",{attrs:{id:"vue中的代码分割"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中的代码分割"}},[e._v("#")]),e._v(" vue中的代码分割")]),e._v(" "),a("p",[e._v("应用程序的代码分割或惰性加载，有助于减少浏览器在初始渲染中下载的资源体积，可以极大地改善大体积 bundle 的"),a("code",[e._v("可交互时间(TTI - time-to-interactive)")]),e._v('。这里的关键在于，对初始首屏而言，"只加载所需”。')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 动态导入()=>import(/* webpackChunkName: \"$webpackChunkName\" */ '$path')\ncomponents: {\n    AddForm: () => import(/* webpackChunkName: \"AddForm\" */ './AddForm.vue')\n}\n")])])]),a("p",[e._v("在 Vue 2.5 以下的版本中，服务端渲染时异步组件只能用在路由组件上。然而在 2.5+ 的版本中，得益于核心算法的升级，异步组件现在可以在应用中的任何地方使用。")]),e._v(" "),a("p",[e._v("chunk是将不同源码模块进行分组，bundle是最终输出的文件")]),e._v(" "),a("h5",{attrs:{id:"webpack打包流程图-友人雪峰提供"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包流程图-友人雪峰提供"}},[e._v("#")]),e._v(" webpack打包流程图(友人雪峰提供)：")]),e._v(" "),a("p",[a("img",{attrs:{src:"/assets/images/chunk.png",alt:""}})])])}),[],!1,null,null,null);t.default=s.exports}}]);