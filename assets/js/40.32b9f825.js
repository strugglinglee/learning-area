(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{474:function(a,t,e){"use strict";e.r(t);var l=e(62),s=Object(l.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("对于异步I/O，虽然并发容易实现，但是由于太容易实现，依然需要控制")]),a._v(" "),e("h3",{attrs:{id:"bagpipe的解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bagpipe的解决方案"}},[a._v("#")]),a._v(" bagpipe的解决方案")]),a._v(" "),e("ul",[e("li",[a._v("通过一个队列来控制并发量。")]),a._v(" "),e("li",[a._v("如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。")]),a._v(" "),e("li",[a._v("如果活跃调用达到限定值，调用暂时存放在队列中。")]),a._v(" "),e("li",[a._v("每个异步调用结束时，从队列中取出新的异步调用执行。")])]),a._v(" "),e("h3",{attrs:{id:"async的解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async的解决方案"}},[a._v("#")]),a._v(" async的解决方案")]),a._v(" "),e("p",[e("strong",[a._v("parallelLimit()")]),a._v("\nparallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。")]),a._v(" "),e("p",[e("strong",[a._v("queue()")]),a._v("\nparallelLimit()方法的缺陷在于无法动态地增加并行任务。为此，async提供了queue()方法来满足该需求，这对于遍历文件目录等操作十分有效。")])])}),[],!1,null,null,null);t.default=s.exports}}]);