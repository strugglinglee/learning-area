(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{538:function(a,e,s){"use strict";s.r(e);var t=s(65),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"loaders"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loaders"}},[a._v("#")]),a._v(" Loaders")]),a._v(" "),s("p",[a._v("将loaders应用于最少数的必要模块中")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('{\n    test: /\\.js$/,\n++  include: path.resolve(__dirname,"src")\n    loader: "babel-loader"\n}\n')])])]),s("h3",{attrs:{id:"解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[a._v("#")]),a._v(" 解析")]),a._v(" "),s("ul",[s("li",[a._v("尽量减少 resolve.modules, resolve.extensions, resolve.mainFiles, resolve.descriptionFiles 中类目的数量，因为他们会增加文件系统调用的次数。")]),a._v(" "),s("li",[a._v("如果你不使用 symlinks ，可以设置 resolve.symlinks: false (例如 npm link 或者 yarn link).")]),a._v(" "),s("li",[a._v("如果你使用自定义解析 plugins ，并且没有指定 context 信息，可以设置 resolve.cacheWithContext: false")])]),a._v(" "),s("h3",{attrs:{id:"dll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dll"}},[a._v("#")]),a._v(" Dll")]),a._v(" "),s("p",[a._v("使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。")]),a._v(" "),s("h3",{attrs:{id:"smaller-faster"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#smaller-faster"}},[a._v("#")]),a._v(" smaller=faster")]),a._v(" "),s("p",[a._v("减少编译的整体大小，以提高构建性能。尽量保持 chunks 小巧。")]),a._v(" "),s("ul",[s("li",[a._v("使用 更少/更小 的库。")]),a._v(" "),s("li",[a._v("在多页面应用程序中使用 CommonsChunksPlugin。")]),a._v(" "),s("li",[a._v("在多页面应用程序中以 async 模式使用 CommonsChunksPlugin 。")]),a._v(" "),s("li",[a._v("移除不使用的代码。")]),a._v(" "),s("li",[a._v("只编译你当前正在开发部分的代码。")])]),a._v(" "),s("h3",{attrs:{id:"worker-pool"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#worker-pool"}},[a._v("#")]),a._v(" worker pool")]),a._v(" "),s("p",[a._v("thread-loader 可以将非常消耗资源的 loaders 转存到 worker pool 中。")]),a._v(" "),s("h3",{attrs:{id:"持久化缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#持久化缓存"}},[a._v("#")]),a._v(" 持久化缓存")]),a._v(" "),s("p",[a._v('使用 cache-loader 启用持久化缓存。使用 package.json 中的 "postinstall" 清除缓存目录。')]),a._v(" "),s("h3",{attrs:{id:"自定义plugins-loaders"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义plugins-loaders"}},[a._v("#")]),a._v(" 自定义plugins/loaders")]),a._v(" "),s("h3",{attrs:{id:"开发环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发环境"}},[a._v("#")]),a._v(" 开发环境")]),a._v(" "),s("h4",{attrs:{id:"增量编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#增量编译"}},[a._v("#")]),a._v(" 增量编译")]),a._v(" "),s("p",[a._v("使用 webpack 的监听模式。不要使用其他工具来监听你的文件和调用 webpack 。在监听模式下构建会记录时间戳并将信息传递给编译让缓存失效。")]),a._v(" "),s("p",[a._v("在某些设置中，监听会回退到轮询模式。有许多监听文件会导致 CPU 大量负载。在这些情况下，你可以使用 watchOptions.poll 来增加轮询的间隔。")]),a._v(" "),s("h4",{attrs:{id:"在内存中编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在内存中编译"}},[a._v("#")]),a._v(" 在内存中编译")]),a._v(" "),s("p",[a._v("以下几个实用工具通过在内存中进行代码的编译和资源的提供，但并不写入磁盘来提高性能:")]),a._v(" "),s("ul",[s("li",[a._v("webpack-dev-server")]),a._v(" "),s("li",[a._v("webpack-hot-middleware")]),a._v(" "),s("li",[a._v("webpack-dev-middleware")])]),a._v(" "),s("h4",{attrs:{id:"devtool"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#devtool"}},[a._v("#")]),a._v(" devtool")]),a._v(" "),s("p",[a._v("需要注意的是不同的 "),s("code",[a._v("devtool")]),a._v(" 的设置，会导致不同的性能差异。")]),a._v(" "),s("ul",[s("li",[a._v('"eval" 具有最好的性能，但并不能帮助你转译代码。')]),a._v(" "),s("li",[a._v("如果你能接受稍差一些的 mapping 质量，可以使用 cheap-source-map 选项来提高性能")]),a._v(" "),s("li",[a._v("使用 eval-source-map 配置进行增量编译。\n=> 在大多数情况下，cheap-module-eval-source-map 是最好的选择。")])]),a._v(" "),s("h4",{attrs:{id:"避免在生产环境下才会用到的工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免在生产环境下才会用到的工具"}},[a._v("#")]),a._v(" 避免在生产环境下才会用到的工具")]),a._v(" "),s("ul",[s("li",[a._v("UglifyJsPlugin")]),a._v(" "),s("li",[a._v("ExtractTextPlugin")]),a._v(" "),s("li",[a._v("[hash]/[chunkhash]")]),a._v(" "),s("li",[a._v("AggressiveSplittingPlugin")]),a._v(" "),s("li",[a._v("AggressiveMergingPlugin")]),a._v(" "),s("li",[a._v("ModuleConcatenationPlugin")])]),a._v(" "),s("h4",{attrs:{id:"最小化入口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最小化入口"}},[a._v("#")]),a._v(" 最小化入口")]),a._v(" "),s("p",[a._v("webpack 只会在文件系统中生成已经更新的 chunk 。对于某些配置选项(HMR, [name]/[chunkhash] in output.chunkFilename, [hash])来说，除了更新的 chunks 无效之外，入口 chunk 也不会生效。")]),a._v(" "),s("p",[a._v("应当在生成入口 chunk 时，尽量减少入口 chunk 的体积，以提高性能。")]),a._v(" "),s("p",[a._v("下述代码块将只提取包含 runtime 的 chunk ，其他 chunk 都作为子模块")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('new CommonsChunkPlugin({\n  name: "manifest",\n  minChunks: Infinity\n})\n')])])]),s("h3",{attrs:{id:"生产环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产环境"}},[a._v("#")]),a._v(" 生产环境")]),a._v(" "),s("h4",{attrs:{id:"多个编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多个编译"}},[a._v("#")]),a._v(" 多个编译")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("parallel-webpack")]),a._v(": 它允许编译工作在 worker 池中进行。")]),a._v(" "),s("li",[s("code",[a._v("cache-loader")]),a._v(": 缓存可以在多个编译时之间共享。")])]),a._v(" "),s("h4",{attrs:{id:"source-maps"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#source-maps"}},[a._v("#")]),a._v(" source maps")]),a._v(" "),s("p",[a._v("很消耗资源？？？？")])])}),[],!1,null,null,null);e.default=r.exports}}]);