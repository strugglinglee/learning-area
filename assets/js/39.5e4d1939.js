(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{480:function(t,v,a){"use strict";a.r(v);var e=a(65),r=Object(e.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("基于无阻塞、事件驱动建立的Node服务，具有内存消耗低的优点，非常适合处理海量的网络请求。在海量请求的前提下，开发者就需要考虑一些平常不会形成影响的问题。")]),t._v(" "),a("blockquote",[a("p",[t._v("“硝烟四起的第三次浏览器大战。那次大战中，来自Google的Chrome浏览器以其优异的性能成为焦点。Chrome成功的背后离不开JavaScript引擎V8。V8出现后，JavaScript一改它作为脚本语言性能低下的形象。在接下来的性能跑分中，V8持续领跑至今。”")])]),t._v(" "),a("p",[t._v("Node是一个构建在Chrome的JavaScript运行时上的平台,V8作为Node的JavaScript脚本引擎")]),t._v(" "),a("h4",{attrs:{id:"v8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8"}},[t._v("#")]),t._v(" v8")]),t._v(" "),a("p",[t._v("node的JS执行引擎")]),t._v(" "),a("h4",{attrs:{id:"内存限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存限制"}},[t._v("#")]),t._v(" 内存限制")]),t._v(" "),a("p",[t._v("一般后端开发语言，在基本的内存使用上没有什么限制")]),t._v(" "),a("p",[t._v("node中通过js使用内存时只能使用部分内存（64位系统下约1.4GB，32位系统下约0.7GB）")]),t._v(" "),a("h4",{attrs:{id:"v8的对象分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8的对象分配"}},[t._v("#")]),t._v(" v8的对象分配")]),t._v(" "),a("p",[t._v("v8中，所有js对象都是通过堆来进行分配的。\n如果已经申请的堆空闲不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。")]),t._v(" "),a("blockquote",[a("p",[t._v("v8限制堆大小的原因\n表层原因：v8最初为浏览器设置，不可能遇到大量内存的场景\n深层原因：v8的垃圾回收机制的限制，以"),a("code",[t._v("1.5GB")]),t._v("的垃圾回收堆内存为例，v8做一次小的垃圾回收需要50ms以上，做一次"),a("code",[t._v("非增量式")]),t._v("的垃圾回收甚至需要1s以上，这是垃圾回收中引起js线程暂停执行的时间，这样的花销下，应用的性能和响应能力都会直线下降，不仅后端服务无法接受，前端浏览器也无法接受。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);