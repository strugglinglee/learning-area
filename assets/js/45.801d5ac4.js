(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{482:function(t,e,a){"use strict";a.r(e);var r=a(62),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"flux架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flux架构"}},[t._v("#")]),t._v(" FLUX架构")]),t._v(" "),a("blockquote",[a("p",[t._v("参考文章:")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/01/flux.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰-Flux架构入门教程"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰-Redux入门教程"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/68449039290634240135",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金文章"),a("OutboundLink")],1)])])]),t._v(" "),a("h2",{attrs:{id:"什么是状态管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是状态管理"}},[t._v("#")]),t._v(" 什么是状态管理")]),t._v(" "),a("p",[t._v("状态管理就是把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。")]),t._v(" "),a("h2",{attrs:{id:"flux基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flux基本概念"}},[t._v("#")]),t._v(" FLUX基本概念")]),t._v(" "),a("p",[t._v("FLUX是一种架构思想，专门解决软件的结构问题")]),t._v(" "),a("p",[a("strong",[t._v("FLUX将一个应用分成四个部分")])]),t._v(" "),a("ul",[a("li",[t._v("View视图层")]),t._v(" "),a("li",[t._v("Action(动作): 视图层发出的消息（比如mouseClick）")]),t._v(" "),a("li",[t._v("Dispatcher(派发器)：用来接收Actions、执行回调函数")]),t._v(" "),a("li",[t._v("Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面")])]),t._v(" "),a("h2",{attrs:{id:"flux单向流动过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flux单向流动过程"}},[t._v("#")]),t._v(" FLUX单向流动过程")]),t._v(" "),a("p",[t._v("保证了流程的清晰")]),t._v(" "),a("ol",[a("li",[t._v("用户访问View")]),t._v(" "),a("li",[t._v("View发出用户的Action")]),t._v(" "),a("li",[t._v("Dispatcher收到Action,要求Store进行相应的更新")]),t._v(" "),a("li",[t._v('Store 更新后，发出一个"change"事件')]),t._v(" "),a("li",[t._v('View 收到"change"事件后，更新页面')])]),t._v(" "),a("h2",{attrs:{id:"flux详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flux详解"}},[t._v("#")]),t._v(" FLUX详解")]),t._v(" "),a("h3",{attrs:{id:"view"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#view"}},[t._v("#")]),t._v(" View")]),t._v(" "),a("p",[t._v("一旦用户操作，调用相关方法，向Dispatcher发出一个Action")]),t._v(" "),a("h3",{attrs:{id:"action"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action"}},[t._v("#")]),t._v(" Action")]),t._v(" "),a("p",[t._v("每个Action都是一个对象，包含一个actionType属性和一些其他的属性")]),t._v(" "),a("ul",[a("li",[t._v("Store的改变只能通过Action")]),t._v(" "),a("li",[t._v("具体Action的处理逻辑一般放在Store里")]),t._v(" "),a("li",[t._v("Action 对象包含 type （类型）与 payload （传递参数）")])]),t._v(" "),a("h3",{attrs:{id:"dispatcher"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dispatcher"}},[t._v("#")]),t._v(" Dispatcher")]),t._v(" "),a("p",[t._v("作用是将Action派发到Store，可以将其看做一个路由器，负责在View和Store之间，建立Action的正确传递路线。")]),t._v(" "),a("p",[t._v("Dispatcher只能有一个，而且是全局的。")]),t._v(" "),a("p",[t._v("只用来派发Action，不应该有其他逻辑")]),t._v(" "),a("h3",{attrs:{id:"store"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store"}},[t._v("#")]),t._v(" Store")]),t._v(" "),a("p",[t._v("保存整个应用的状态，需要在变动后向View发送change事件，必须实现事件接口\n数据层，存放应用状态与更新状态的方法，一旦发生变动，就提醒 Views 更新页面")]),t._v(" "),a("h2",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),a("p",[t._v("将Flux与函数式编程结合在一起")]),t._v(" "),a("h3",{attrs:{id:"设计思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),a("ol",[a("li",[t._v("web应用是一个状态机，视图与状态是一一对应的")]),t._v(" "),a("li",[t._v("所有的状态，保存在一个对象里面")])]),t._v(" "),a("h3",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("h4",{attrs:{id:"store-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-2"}},[t._v("#")]),t._v(" store")]),t._v(" "),a("p",[t._v("保存数据的地方，可以看成一个容器。整个应用只能有一个Store。")]),t._v(" "),a("p",[t._v("redux提供createStore这个函数用来生成Store")]),t._v(" "),a("h4",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" state")]),t._v(" "),a("p",[t._v("Store对象包含所有数据。如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合叫做State。")]),t._v(" "),a("p",[t._v("当前时刻的state,可以通过store.getState()拿到")]),t._v(" "),a("p",[t._v("一个State对应一个View，是要State相同，View就相同。")]),t._v(" "),a("h4",{attrs:{id:"action-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action-2"}},[t._v("#")]),t._v(" Action")]),t._v(" "),a("p",[t._v("state 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。\nAction 就是 View 发出的通知，表示 State 应该要发生变化了。")]),t._v(" "),a("p",[t._v("Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。")]),t._v(" "),a("p",[t._v("Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。")]),t._v(" "),a("h4",{attrs:{id:"store-dispatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-dispatch"}},[t._v("#")]),t._v(" store.dispatch()")]),t._v(" "),a("p",[t._v("store.dispatch()是 View 发出 Action 的唯一方法。\nstore.dispatch接受一个 Action 对象作为参数，将它发送出去。")]),t._v(" "),a("h4",{attrs:{id:"reducer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reducer"}},[t._v("#")]),t._v(" Reducer")]),t._v(" "),a("p",[t._v("Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。\n这种 State 的"),a("strong",[t._v("计算过程")]),t._v("就叫做 Reducer。")]),t._v(" "),a("p",[t._v("Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。")]),t._v(" "),a("p",[t._v("createStore接受 Reducer 作为参数，生成一个新的 Store。\n以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。")]),t._v(" "),a("h5",{attrs:{id:"纯函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[t._v("#")]),t._v(" 纯函数")]),t._v(" "),a("p",[t._v("Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。")]),t._v(" "),a("p",[t._v("纯函数是函数式编程的概念，必须遵守以下一些约束。")]),t._v(" "),a("ul",[a("li",[t._v("不得改写参数")]),t._v(" "),a("li",[t._v("不能调用系统 I/O 的API")]),t._v(" "),a("li",[t._v("不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果")])]),t._v(" "),a("p",[t._v("由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。\n但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象")]),t._v(" "),a("p",[t._v("最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。\n这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。")]),t._v(" "),a("h4",{attrs:{id:"store-subscribe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-subscribe"}},[t._v("#")]),t._v(" store.subscribe()")]),t._v(" "),a("p",[t._v("Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。")]),t._v(" "),a("p",[t._v("只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。")]),t._v(" "),a("p",[t._v("store.subscribe方法返回一个函数，调用这个函数就可以解除监听。")]),t._v(" "),a("h4",{attrs:{id:"middleware"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#middleware"}},[t._v("#")]),t._v(" Middleware")]),t._v(" "),a("p",[t._v("Redux 还支持中间件，用于管理异步数据流。\n常用库：redux-actions, redux-thunk, redux-promise 。")]),t._v(" "),a("h4",{attrs:{id:"combinereducers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#combinereducers"}},[t._v("#")]),t._v(" combineReducers")]),t._v(" "),a("p",[t._v("Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。\n你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。")]),t._v(" "),a("h3",{attrs:{id:"react-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" React-Router")]),t._v(" "),a("p",[t._v("使用Provide在Router外面包一层，Provide唯一的功能就是传入Store对象")]),t._v(" "),a("h3",{attrs:{id:"redux特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux特点"}},[t._v("#")]),t._v(" redux特点")]),t._v(" "),a("ul",[a("li",[t._v("**单向数据流。**View 发出 Action (store.dispatch(action))，Store 调用 Reducer 计算出新的 state ，若 state 产生变化，则调用监听函数重新渲染 View （store.subscribe(render)）")]),t._v(" "),a("li",[a("strong",[t._v("单一数据源")]),t._v("，只有一个 Store")]),t._v(" "),a("li",[a("strong",[t._v("state 是只读的")]),t._v("，每次状态更新之后只能返回一个新的 state")]),t._v(" "),a("li",[a("strong",[t._v("没有 Dispatcher")]),t._v(" ，而是在 Store 中集成了 dispatch 方法，"),a("strong",[t._v("store.dispatch() 是 View 发出 Action 的唯一途径")])]),t._v(" "),a("li",[t._v("支持使用**中间件（Middleware）**管理异步数据流")])]),t._v(" "),a("h2",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),a("h3",{attrs:{id:"基本概念-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念-2"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("h4",{attrs:{id:"store-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-3"}},[t._v("#")]),t._v(" Store")]),t._v(" "),a("p",[t._v("Vuex 采用单一状态树，每个应用仅有一个 Store 实例，在该实例下包含了 state, actions, mutations, getters, modules")]),t._v(" "),a("h4",{attrs:{id:"state-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-2"}},[t._v("#")]),t._v(" State")]),t._v(" "),a("p",[t._v("Vuex 为单一数据源")]),t._v(" "),a("p",[t._v("可以通过 mapState 辅助函数将 state 作为计算属性访问，或者将通过 Store 将 state 注入全局之后使用 this.$store.state 访问\nState 更新视图是通过 vue 的双向绑定机制实现的")]),t._v(" "),a("h4",{attrs:{id:"getter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[t._v("#")]),t._v(" Getter")]),t._v(" "),a("p",[t._v("Getter 的作用与 filters 有一些相似，可以将 State 进行过滤后输出")]),t._v(" "),a("h4",{attrs:{id:"mutation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mutation"}},[t._v("#")]),t._v(" Mutation")]),t._v(" "),a("p",[t._v("Mutaion 是 vuex 中改变 State 的唯一途径（严格模式下），并且只能是同步操作。Vuex 中通过 store.commit() 调用 Mutation")]),t._v(" "),a("h4",{attrs:{id:"action-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action-3"}},[t._v("#")]),t._v(" Action")]),t._v(" "),a("p",[t._v("一些对 State 的异步操作可以放在 Action 中，并通过在 Action 提交 Mutaion 变更状态")]),t._v(" "),a("p",[t._v("Action 通过 store.dispatch() 方法触发\n可以通过 mapActions 辅助函数将 vue 组件的 methods 映射成 store.dispatch 调用（需要先在根节点注入 store）")]),t._v(" "),a("h4",{attrs:{id:"module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[t._v("#")]),t._v(" Module")]),t._v(" "),a("p",[t._v("当 Store 对象过于庞大时，可根据具体的业务需求分为多个 Module ，每个 Module 都具有自己的 state 、mutation 、action 、getter")]),t._v(" "),a("h3",{attrs:{id:"vuex-的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的特点"}},[t._v("#")]),t._v(" Vuex 的特点")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("单向数据流")]),t._v("。View 通过 store.dispatch() 调用 Action ，在 Action 执行完异步操作之后通过 store.commit() 调用 Mutation 更新 State ，通过 vue 的响应式机制进行视图更新")]),t._v(" "),a("li",[a("strong",[t._v("单一数据源")]),t._v("，和 Redux 一样"),a("strong",[t._v("全局只有一个 Store 实例")])]),t._v(" "),a("li",[a("strong",[t._v("只能应用于 Vue")])])]),t._v(" "),a("h2",{attrs:{id:"vuex-vs-redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-vs-redux"}},[t._v("#")]),t._v(" Vuex vs Redux")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("Redux")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("Vuex")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("action （同步action ，或借助 中间件 实现异步操作，action 不会改变 store，只是描述了怎么改变store）")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("mutation（用于同步操作） 、action（可用于异步操作，提交 mutation）")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("reducer（纯函数，根据 action 和旧的 store 计算出新的 store")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("mutation里面直接修改 state")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("store.getState() 这个 API 获取 store 树，还有 store.subscribe(listener) 订阅 store 的变化，当 store 改变时会调用监听器；")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("Vuex 有一个 getter 的概念用于根据 state 派生出一些数据，像 Vue 的计算属性一样，当 state 改变时会重新计算出一个结果出来，提供给需要的组件。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("通过 combineReducers（）结合各个组件的 reducer，各个组件可以单独管理自己的状态，最后合并为一个 reducer 用于生成一个 store")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("用 Module 这个概念划分 store，与 Redux 一样，可以多层嵌套子状态。")])])])]),t._v(" "),a("h3",{attrs:{id:"redux-的三大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-的三大原则"}},[t._v("#")]),t._v(" Redux 的三大原则：")]),t._v(" "),a("ol",[a("li",[t._v("单一数据源（一个Redux应用只有一个store），也是单向的数据流")]),t._v(" "),a("li",[t._v("state只读（唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。")]),t._v(" "),a("li",[t._v("使用纯函数（reducer）来修改state。")])]),t._v(" "),a("p",[t._v("Redux 得益于 "),a("strong",[t._v("中间件机制")]),t._v("，利用 "),a("code",[t._v("redux-thunk")]),t._v("（redux-thunk 可以 dispatch 函数，这个函数用于生成 action，所以在这个函数里面我们可以进行异步操作，等异步的结果出来后再放在 action 里面将这个 action 用 dispatch 分发出去, 而这个函数被叫做 “action creator” ），可以将异步逻辑放在  "),a("code",[t._v("action creator")]),t._v(" 里面，"),a("strong",[t._v("通过 action creator 做一个控制反转")]),t._v("， 给 action creator 传入 dispatch 作为参数，于是就可以 dispatch  action，（原本是通过 dispatch 来分发 action ,现在是异步 action 即 action creator 掌握了控制权调用 dispatch，所以叫控制反转）")]),t._v(" "),a("p",[t._v("Redux 并没有创造单独的概念出来专门用于异步逻辑，它是利用了 Redux 自己实现的中间件机制，中间件从 dispatch 一个异步 action 到 action 到达 reducer 之间处理 action，在这期间通过异步操作得到的结果可以放到 action 里面再通过 dispatch 分发到 reducer，以前 dispatch 一个 action 之后，这个 action 回立即到达 reducer ，所以是同步 action，现在在 action creator 里面，我们通过控制反转，可以等待异步操作结果再生成 action 分发，所以叫做异步 action：")]),t._v(" "),a("h3",{attrs:{id:"vuex-的三大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的三大原则"}},[t._v("#")]),t._v(" Vuex 的三大原则：")]),t._v(" "),a("ol",[a("li",[t._v("应用层级的状态应该集中到单个 store 对象中。")]),t._v(" "),a("li",[t._v("提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。")]),t._v(" "),a("li",[t._v("异步逻辑都应该封装到 action 里面。")])]),t._v(" "),a("p",[t._v("Vuex 是用 mutation 来对应 Redux 的 action，另外 Vuex 又创造了一个 action 来提交 mutation 并通过异步提交 mutation 来实现异步操作结果能够到达 state.")])])}),[],!1,null,null,null);e.default=s.exports}}]);