(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{340:function(s,t,a){"use strict";a.r(t);var r=a(13),v=Object(r.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h3",{attrs:{id:"esbuild"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esbuild"}},[s._v("#")]),s._v(" esbuild")]),s._v(" "),t("p",[s._v("是一个js Bundler打包和压缩工具，可以将js和ts代码打包分发在网页上运行")]),s._v(" "),t("h3",{attrs:{id:"支持的功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持的功能"}},[s._v("#")]),s._v(" 支持的功能")]),s._v(" "),t("ul",[t("li",[s._v("加载器")]),s._v(" "),t("li",[s._v("压缩")]),s._v(" "),t("li",[s._v("打包")]),s._v(" "),t("li",[s._v("tree shaking")]),s._v(" "),t("li",[s._v("source map生成")]),s._v(" "),t("li",[s._v("将jsx和较新的js语法移植到ES6")]),s._v(" "),t("li",[s._v("......")])]),s._v(" "),t("h3",{attrs:{id:"esbulid会比其他的打包工具快至少100倍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esbulid会比其他的打包工具快至少100倍"}},[s._v("#")]),s._v(" esbulid会比其他的打包工具快至少100倍")]),s._v(" "),t("h4",{attrs:{id:"原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[s._v("#")]),s._v(" 原因")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("Go语言")]),s._v("编写而成，可以编译成本地代码")]),s._v(" "),t("li",[s._v("解析，生成最终文件和生成source maps全部完全并行化")]),s._v(" "),t("li",[s._v("无需昂贵的数据转换，很少几步可以完成所有操作")]),s._v(" "),t("li",[s._v("该库以提高编译速度为编写代码时的第一原则，并尽量避免不必要的内存分配")])]),s._v(" "),t("h3",{attrs:{id:"esbuild-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#esbuild-api"}},[s._v("#")]),s._v(" esbuild API")]),s._v(" "),t("h4",{attrs:{id:"transform"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transform"}},[s._v("#")]),s._v(" transform")]),s._v(" "),t("p",[s._v("可以用于转化js/tsx/ts等文件，然后输出为旧语法的js")]),s._v(" "),t("h4",{attrs:{id:"build"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#build"}},[s._v("#")]),s._v(" build")]),s._v(" "),t("p",[s._v("build 实现了 transform 的能力，即代码转化，并且它还会将转换后的代码压缩并生成 .js 文件到指定 output 目录")]),s._v(" "),t("h4",{attrs:{id:"buildsync"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#buildsync"}},[s._v("#")]),s._v(" buildSync")]),s._v(" "),t("p",[s._v("相比较 build 而言，它是同步的构建方式，即如果使用 build 我们需要借助 async await 来实现同步调用，而使用 buildSync 可以直接实现同步调用")]),s._v(" "),t("h4",{attrs:{id:"service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service"}},[s._v("#")]),s._v(" service")]),s._v(" "),t("p",[s._v("为了解决调用上述 API 时都会创建一个子进行来完成的问题，如果存在多次调用 API 的情况出现，那么就会出现性能上的浪费")]),s._v(" "),t("p",[s._v("本质封装了 build、transform、stop 函数，只是不同于单独调用它们，Service 底层的实现是一个长期存在可供共享的子进程。")])])}),[],!1,null,null,null);t.default=v.exports}}]);