(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{450:function(t,e,a){"use strict";a.r(e);var r=a(62),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"核心概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心概念"}},[t._v("#")]),t._v(" 核心概念")]),t._v(" "),a("h4",{attrs:{id:"image"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#image"}},[t._v("#")]),t._v(" Image")]),t._v(" "),a("p",[t._v("和windows和iso镜像相比，Docker中的镜像是分层的，可复用的。不是简单的一堆文件叠在一起（类似于压缩包的源码和git仓库的区别）")]),t._v(" "),a("h4",{attrs:{id:"container"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#container"}},[t._v("#")]),t._v(" Container")]),t._v(" "),a("p",[t._v("容器的存在离不开镜像的支持，它是镜像运行时的一个载体（类似于实例和类的关系）。依托Docker的虚拟化技术，给容器创建了独立的端口、进程、文件等“空间”。\n是一个与宿机隔离“容器”，容器和宿主机之间可以进行port/volumes/network等的通信。")]),t._v(" "),a("h4",{attrs:{id:"repository"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#repository"}},[t._v("#")]),t._v(" Repository")]),t._v(" "),a("p",[t._v("Docker的仓库和git的仓库比较相似，拥有仓库名，tag。在本地构建完镜像之后，即可通过仓库进行镜像的分发。")]),t._v(" "),a("h3",{attrs:{id:"版本分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本分类"}},[t._v("#")]),t._v(" 版本分类")]),t._v(" "),a("p",[t._v("Docker分为"),a("code",[t._v("社区版(CE)")]),t._v("和"),a("code",[t._v("企业版(EE)")]),t._v("两个版本，社区版本可以免费使用，而企业版则需要付费使用，对于我们个人开发者或小企业来说，一般是使用社区版的。")]),t._v(" "),a("p",[t._v("Docker CE有三个更新频道，分别为"),a("code",[t._v("stable")]),t._v("、"),a("code",[t._v("test")]),t._v("、"),a("code",[t._v("nightly")]),t._v("，stable是稳定版本，test是测试后的预发布版本，而nightly则是开发中准备在下一个版本正式发布的版本，我们可以根据自己的需求下载安装。")]),t._v(" "),a("p",[t._v("从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。")])])}),[],!1,null,null,null);e.default=s.exports}}]);