(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{473:function(t,a,s){"use strict";s.r(a);var r=s(65),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"对象、类与面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象、类与面向对象"}},[t._v("#")]),t._v(" 对象、类与面向对象")]),t._v(" "),s("h2",{attrs:{id:"对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[t._v("#")]),t._v(" 对象")]),t._v(" "),s("h3",{attrs:{id:"合并对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并对象"}},[t._v("#")]),t._v(" 合并对象")]),t._v(" "),s("p",[s("code",[t._v("Object.assgin()")]),t._v("实际上对每个源对象执行的是浅复制，会覆盖重复的值。")]),t._v(" "),s("h2",{attrs:{id:"构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数")]),t._v(" "),s("p",[t._v("构造函数与普通函数唯一的区别就是调用方式不同，除此之外，构造函数也是函数。")]),t._v(" "),s("p",[t._v("任何函数只要使用new操作符调用就是构造函数。")]),t._v(" "),s("h3",{attrs:{id:"构造函数的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的问题"}},[t._v("#")]),t._v(" 构造函数的问题")]),t._v(" "),s("p",[t._v("其定义的方法会在每个实例上都创建一遍。会带来不同的作用域链和标识符解析，但创建新Function实例的机制是一样的。")]),t._v(" "),s("p",[t._v("都是做一样的事，没必要定义两个不同的Function实例，况且this对象可以吧函数与对象的绑定推迟到运行时。")]),t._v(" "),s("h2",{attrs:{id:"原型模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[t._v("#")]),t._v(" 原型模式")]),t._v(" "),s("h3",{attrs:{id:"原型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),s("p",[t._v("无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）")])])}),[],!1,null,null,null);a.default=e.exports}}]);